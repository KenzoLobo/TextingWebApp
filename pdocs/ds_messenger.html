<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ds_messenger API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ds_messenger</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Harshal Patel
# harshalp@uci.edu
# 93592684

import ds_protocol as dsp
import socket
import json


class DirectMessage(dict):
    &#34;&#34;&#34;

    The Direct Message class stores all relevant information for a message in the following instance variables:

    - self.recipient: stores who is to receive the message of the message
    - self.message: stores the message itself
    - self.timestamp: stores the time that the message was sent
    - self.frm: stores who the message was sent by


    &#34;&#34;&#34;

    def __init__(self, message: str = None, timestamp: float = 0, recipient: str = None, frm: str = None):
        self._message = message
        self._timestamp = timestamp
        self._recipient = recipient
        self._frm = frm

        self.set_timestamp(timestamp)
        self.set_message(message)
        self.set_recipient(recipient)
        self.set_frm(frm)

        # Subclass dict to expose Post properties for serialization
        # Don&#39;t worry about this!
        dict.__init__(self, message=self._message, timestamp=self._timestamp, recipient=self._recipient, frm=self._frm)

    def set_message(self, message):
        self._message = message
        dict.__setitem__(self, &#39;message&#39;, message)

    def set_recipient(self, recipient):
        self._recipient = recipient
        dict.__setitem__(self, &#39;recipient&#39;, recipient)

    def set_frm(self, frm):
        self._frm = frm
        dict.__setitem__(self, &#39;from&#39;, frm)

    def set_timestamp(self, timestamp):
        self._timestamp = float(timestamp)
        dict.__setitem__(self, &#39;timestamp&#39;, float(timestamp))

    def get_message(self):
        return self._message

    def get_time(self):
        return self._timestamp





class DirectMessenger:
    &#34;&#34;&#34;
    The DirectMessenger class can be used to send and retrieve messages from the DSU server.

    It takes the following parameters upon initialization:

    :param username: The username to be assigned to the message.

    :param password: The password associated with the username

    *** Although the username and password parameters are &#34;optional&#34; and set to none, that&#39;s just how they were set in
    the starter code. I left them as is to avoid errors with the grading tool, but really they are mandatory and joining
    and sending and retrieving messages will only work successfully with a valid username and password pair. ***

    :param dsuserver: The IP address of the dsu server you would like to communicate with (default is set to the
    ICS 32 Distributed Social Website.

    :param port: The port used to connect to the server (default is set to the port used by the ICS 32 Distributed
     Social Website.

     DirectMessenger also saves all sent messages to the instance variable self.sent_messages as a List object.


    &#34;&#34;&#34;

    def __init__(self, dsuserver=&#34;168.235.86.101&#34;, username=None, password=None, port=3021):
        self.token = None
        self.dsuserver = dsuserver
        self.port = port
        self.username = username
        self.password = password
        self.join_ok = False
        self.sent_messages = []

    def send(self, message, recipient) -&gt; bool:
        &#34;&#34;&#34;
        Takes a message (as a string) and recipient (as a string) and sends a message to the server requesting to send
         a message to the specified recipient.
        &#34;&#34;&#34;

        server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;send&#34;,
                                                     message=message, recipient=recipient)

        # Checks to see if the message was successfully sent and returns the appropriate boolean
        # (true if message successfully sent, false if send failed.)

        if server_response[&#34;response&#34;][&#34;message&#34;] == &#34;Direct message sent&#34;:

            # saves the message that was successfully sent to the server
            msgdict = dsp.get_msg_dict(message=message, recipient=recipient)
            dm = DirectMessage(timestamp=msgdict[&#34;timestamp&#34;], message=msgdict[&#34;message&#34;], recipient=msgdict[&#34;recipient&#34;], frm=self.username)
            # dm.fill_info_sent(messagedict=messagedict, myusername=self.username)
            self.sent_messages.append(dm)

            return True
        else:
            return False

    def retrieve_new(self) -&gt; list:
        &#34;&#34;&#34;
        returns a list of DirectMessage objects containing all new messages
        &#34;&#34;&#34;

        server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;new&#34;)

        messages = server_response[&#34;response&#34;][&#34;messages&#34;]
        messagelist = []
        for message in messages:
            newmessage = DirectMessage(timestamp=message[&#34;timestamp&#34;], message=message[&#34;message&#34;], recipient=self.username, frm=message[&#34;from&#34;])
            # newmessage.fill_info_received(message, self.username)
            messagelist.append(newmessage)

        return messagelist

    def retrieve_all(self) -&gt; list:
        &#34;&#34;&#34;
        returns a list of DirectMessage objects containing all messages
        &#34;&#34;&#34;
        server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;all&#34;)

        messages = server_response[&#34;response&#34;][&#34;messages&#34;]
        messagelist = []
        for message in messages:
            newmessage = DirectMessage(timestamp=message[&#34;timestamp&#34;], message=message[&#34;message&#34;], recipient=self.username, frm=message[&#34;from&#34;])
            # newmessage.fill_info_received(message, self.username)
            messagelist.append(newmessage)

        return messagelist

    def _communicate_w_server(self, server: str, port: int, taip: str, message=str,
                              recipient=str):
        &#34;&#34;&#34;
    The send function joins a ds server and sends a message, bio, or both

    :param server: The ip address for the ICS 32 DS server.
    :param port: The port where the ICS 32 DS server is accepting connections.
    :param taip: The type of communication wanted -- &#34;send&#34; to send a direct message,&#34;new&#34; to retrieve new messages,
                 or &#34;all&#34; to retrieve all received messages.
    :param message: the direct message you wish to send
    :param recipient: the username of the user you want to send a message to.

    &#34;&#34;&#34;
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
                client.connect((server, port))
                joinresponse = self._send_to_server(client=client, username=self.username, password=self.password,
                                                    typ=&#34;join&#34;)

                if dsp.get_responseType(joinresponse) == &#34;ok&#34;:
                    token = dsp.get_token(joinresponse)
                    self.token = token
                    self.join_ok = True

                    if taip == &#34;send&#34;:
                        if self.join_ok:
                            server_response = self._send_to_server(client=client, token=token, message=message,
                                                                   recipient=recipient, typ=taip)

                    else:
                        server_response = self._send_to_server(client=client, token=token, typ=taip)

                else:
                    dsp.incorrectlogin_response()
        except socket.gaierror:
            print(&#34;Unable to connect to server, please try again with a valid IP address and Port number!&#34;)

        return server_response

    def _send_to_server(self, client, username=None, password=None, token=None, message=None, recipient=None, typ=None):

        &#34;&#34;&#34;Sends a join message to connect and retrieve a token for the requested account.&#34;&#34;&#34;

        join_send = client.makefile(&#39;w&#39;)
        join_recv = client.makefile(&#39;r&#39;)

        # print(&#34;client connected to {HOST} on {PORT}&#34;)
        # print()
        if typ == &#34;join&#34;:
            msg = dsp.get_joinmsg(username, password)
        elif typ == &#34;send&#34;:
            msg = dsp.get_sendmsg(token, message, recipient)
        else:
            msg = dsp.get_rtrmsg(token, typ)

        join_send.write(msg + &#39;\r\n&#39;)
        join_send.flush()
        srv_msg = join_recv.readline()
        msg_dict = dsp.load_srvmsg(srv_msg)
        # print(srv_msg)
        dsp.print_rMessage(msg_dict)

        return msg_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ds_messenger.DirectMessage"><code class="flex name class">
<span>class <span class="ident">DirectMessage</span></span>
<span>(</span><span>message: str = None, timestamp: float = 0, recipient: str = None, frm: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Direct Message class stores all relevant information for a message in the following instance variables:</p>
<ul>
<li>self.recipient: stores who is to receive the message of the message</li>
<li>self.message: stores the message itself</li>
<li>self.timestamp: stores the time that the message was sent</li>
<li>self.frm: stores who the message was sent by</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectMessage(dict):
    &#34;&#34;&#34;

    The Direct Message class stores all relevant information for a message in the following instance variables:

    - self.recipient: stores who is to receive the message of the message
    - self.message: stores the message itself
    - self.timestamp: stores the time that the message was sent
    - self.frm: stores who the message was sent by


    &#34;&#34;&#34;

    def __init__(self, message: str = None, timestamp: float = 0, recipient: str = None, frm: str = None):
        self._message = message
        self._timestamp = timestamp
        self._recipient = recipient
        self._frm = frm

        self.set_timestamp(timestamp)
        self.set_message(message)
        self.set_recipient(recipient)
        self.set_frm(frm)

        # Subclass dict to expose Post properties for serialization
        # Don&#39;t worry about this!
        dict.__init__(self, message=self._message, timestamp=self._timestamp, recipient=self._recipient, frm=self._frm)

    def set_message(self, message):
        self._message = message
        dict.__setitem__(self, &#39;message&#39;, message)

    def set_recipient(self, recipient):
        self._recipient = recipient
        dict.__setitem__(self, &#39;recipient&#39;, recipient)

    def set_frm(self, frm):
        self._frm = frm
        dict.__setitem__(self, &#39;from&#39;, frm)

    def set_timestamp(self, timestamp):
        self._timestamp = float(timestamp)
        dict.__setitem__(self, &#39;timestamp&#39;, float(timestamp))

    def get_message(self):
        return self._message

    def get_time(self):
        return self._timestamp</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ds_messenger.DirectMessage.get_message"><code class="name flex">
<span>def <span class="ident">get_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_message(self):
    return self._message</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self):
    return self._timestamp</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.set_frm"><code class="name flex">
<span>def <span class="ident">set_frm</span></span>(<span>self, frm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frm(self, frm):
    self._frm = frm
    dict.__setitem__(self, &#39;from&#39;, frm)</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.set_message"><code class="name flex">
<span>def <span class="ident">set_message</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_message(self, message):
    self._message = message
    dict.__setitem__(self, &#39;message&#39;, message)</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.set_recipient"><code class="name flex">
<span>def <span class="ident">set_recipient</span></span>(<span>self, recipient)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_recipient(self, recipient):
    self._recipient = recipient
    dict.__setitem__(self, &#39;recipient&#39;, recipient)</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessage.set_timestamp"><code class="name flex">
<span>def <span class="ident">set_timestamp</span></span>(<span>self, timestamp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timestamp(self, timestamp):
    self._timestamp = float(timestamp)
    dict.__setitem__(self, &#39;timestamp&#39;, float(timestamp))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ds_messenger.DirectMessenger"><code class="flex name class">
<span>class <span class="ident">DirectMessenger</span></span>
<span>(</span><span>dsuserver='168.235.86.101', username=None, password=None, port=3021)</span>
</code></dt>
<dd>
<div class="desc"><p>The DirectMessenger class can be used to send and retrieve messages from the DSU server.</p>
<p>It takes the following parameters upon initialization:</p>
<p>:param username: The username to be assigned to the message.</p>
<p>:param password: The password associated with the username</p>
<p><strong><em> Although the username and password parameters are "optional" and set to none, that's just how they were set in
the starter code. I left them as is to avoid errors with the grading tool, but really they are mandatory and joining
and sending and retrieving messages will only work successfully with a valid username and password pair. </em></strong></p>
<p>:param dsuserver: The IP address of the dsu server you would like to communicate with (default is set to the
ICS 32 Distributed Social Website.</p>
<p>:param port: The port used to connect to the server (default is set to the port used by the ICS 32 Distributed
Social Website.</p>
<p>DirectMessenger also saves all sent messages to the instance variable self.sent_messages as a List object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectMessenger:
    &#34;&#34;&#34;
    The DirectMessenger class can be used to send and retrieve messages from the DSU server.

    It takes the following parameters upon initialization:

    :param username: The username to be assigned to the message.

    :param password: The password associated with the username

    *** Although the username and password parameters are &#34;optional&#34; and set to none, that&#39;s just how they were set in
    the starter code. I left them as is to avoid errors with the grading tool, but really they are mandatory and joining
    and sending and retrieving messages will only work successfully with a valid username and password pair. ***

    :param dsuserver: The IP address of the dsu server you would like to communicate with (default is set to the
    ICS 32 Distributed Social Website.

    :param port: The port used to connect to the server (default is set to the port used by the ICS 32 Distributed
     Social Website.

     DirectMessenger also saves all sent messages to the instance variable self.sent_messages as a List object.


    &#34;&#34;&#34;

    def __init__(self, dsuserver=&#34;168.235.86.101&#34;, username=None, password=None, port=3021):
        self.token = None
        self.dsuserver = dsuserver
        self.port = port
        self.username = username
        self.password = password
        self.join_ok = False
        self.sent_messages = []

    def send(self, message, recipient) -&gt; bool:
        &#34;&#34;&#34;
        Takes a message (as a string) and recipient (as a string) and sends a message to the server requesting to send
         a message to the specified recipient.
        &#34;&#34;&#34;

        server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;send&#34;,
                                                     message=message, recipient=recipient)

        # Checks to see if the message was successfully sent and returns the appropriate boolean
        # (true if message successfully sent, false if send failed.)

        if server_response[&#34;response&#34;][&#34;message&#34;] == &#34;Direct message sent&#34;:

            # saves the message that was successfully sent to the server
            msgdict = dsp.get_msg_dict(message=message, recipient=recipient)
            dm = DirectMessage(timestamp=msgdict[&#34;timestamp&#34;], message=msgdict[&#34;message&#34;], recipient=msgdict[&#34;recipient&#34;], frm=self.username)
            # dm.fill_info_sent(messagedict=messagedict, myusername=self.username)
            self.sent_messages.append(dm)

            return True
        else:
            return False

    def retrieve_new(self) -&gt; list:
        &#34;&#34;&#34;
        returns a list of DirectMessage objects containing all new messages
        &#34;&#34;&#34;

        server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;new&#34;)

        messages = server_response[&#34;response&#34;][&#34;messages&#34;]
        messagelist = []
        for message in messages:
            newmessage = DirectMessage(timestamp=message[&#34;timestamp&#34;], message=message[&#34;message&#34;], recipient=self.username, frm=message[&#34;from&#34;])
            # newmessage.fill_info_received(message, self.username)
            messagelist.append(newmessage)

        return messagelist

    def retrieve_all(self) -&gt; list:
        &#34;&#34;&#34;
        returns a list of DirectMessage objects containing all messages
        &#34;&#34;&#34;
        server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;all&#34;)

        messages = server_response[&#34;response&#34;][&#34;messages&#34;]
        messagelist = []
        for message in messages:
            newmessage = DirectMessage(timestamp=message[&#34;timestamp&#34;], message=message[&#34;message&#34;], recipient=self.username, frm=message[&#34;from&#34;])
            # newmessage.fill_info_received(message, self.username)
            messagelist.append(newmessage)

        return messagelist

    def _communicate_w_server(self, server: str, port: int, taip: str, message=str,
                              recipient=str):
        &#34;&#34;&#34;
    The send function joins a ds server and sends a message, bio, or both

    :param server: The ip address for the ICS 32 DS server.
    :param port: The port where the ICS 32 DS server is accepting connections.
    :param taip: The type of communication wanted -- &#34;send&#34; to send a direct message,&#34;new&#34; to retrieve new messages,
                 or &#34;all&#34; to retrieve all received messages.
    :param message: the direct message you wish to send
    :param recipient: the username of the user you want to send a message to.

    &#34;&#34;&#34;
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
                client.connect((server, port))
                joinresponse = self._send_to_server(client=client, username=self.username, password=self.password,
                                                    typ=&#34;join&#34;)

                if dsp.get_responseType(joinresponse) == &#34;ok&#34;:
                    token = dsp.get_token(joinresponse)
                    self.token = token
                    self.join_ok = True

                    if taip == &#34;send&#34;:
                        if self.join_ok:
                            server_response = self._send_to_server(client=client, token=token, message=message,
                                                                   recipient=recipient, typ=taip)

                    else:
                        server_response = self._send_to_server(client=client, token=token, typ=taip)

                else:
                    dsp.incorrectlogin_response()
        except socket.gaierror:
            print(&#34;Unable to connect to server, please try again with a valid IP address and Port number!&#34;)

        return server_response

    def _send_to_server(self, client, username=None, password=None, token=None, message=None, recipient=None, typ=None):

        &#34;&#34;&#34;Sends a join message to connect and retrieve a token for the requested account.&#34;&#34;&#34;

        join_send = client.makefile(&#39;w&#39;)
        join_recv = client.makefile(&#39;r&#39;)

        # print(&#34;client connected to {HOST} on {PORT}&#34;)
        # print()
        if typ == &#34;join&#34;:
            msg = dsp.get_joinmsg(username, password)
        elif typ == &#34;send&#34;:
            msg = dsp.get_sendmsg(token, message, recipient)
        else:
            msg = dsp.get_rtrmsg(token, typ)

        join_send.write(msg + &#39;\r\n&#39;)
        join_send.flush()
        srv_msg = join_recv.readline()
        msg_dict = dsp.load_srvmsg(srv_msg)
        # print(srv_msg)
        dsp.print_rMessage(msg_dict)

        return msg_dict</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ds_messenger.DirectMessenger.retrieve_all"><code class="name flex">
<span>def <span class="ident">retrieve_all</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>returns a list of DirectMessage objects containing all messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_all(self) -&gt; list:
    &#34;&#34;&#34;
    returns a list of DirectMessage objects containing all messages
    &#34;&#34;&#34;
    server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;all&#34;)

    messages = server_response[&#34;response&#34;][&#34;messages&#34;]
    messagelist = []
    for message in messages:
        newmessage = DirectMessage(timestamp=message[&#34;timestamp&#34;], message=message[&#34;message&#34;], recipient=self.username, frm=message[&#34;from&#34;])
        # newmessage.fill_info_received(message, self.username)
        messagelist.append(newmessage)

    return messagelist</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.retrieve_new"><code class="name flex">
<span>def <span class="ident">retrieve_new</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>returns a list of DirectMessage objects containing all new messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_new(self) -&gt; list:
    &#34;&#34;&#34;
    returns a list of DirectMessage objects containing all new messages
    &#34;&#34;&#34;

    server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;new&#34;)

    messages = server_response[&#34;response&#34;][&#34;messages&#34;]
    messagelist = []
    for message in messages:
        newmessage = DirectMessage(timestamp=message[&#34;timestamp&#34;], message=message[&#34;message&#34;], recipient=self.username, frm=message[&#34;from&#34;])
        # newmessage.fill_info_received(message, self.username)
        messagelist.append(newmessage)

    return messagelist</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, message, recipient) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a message (as a string) and recipient (as a string) and sends a message to the server requesting to send
a message to the specified recipient.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, message, recipient) -&gt; bool:
    &#34;&#34;&#34;
    Takes a message (as a string) and recipient (as a string) and sends a message to the server requesting to send
     a message to the specified recipient.
    &#34;&#34;&#34;

    server_response = self._communicate_w_server(server=self.dsuserver, port=self.port, taip=&#34;send&#34;,
                                                 message=message, recipient=recipient)

    # Checks to see if the message was successfully sent and returns the appropriate boolean
    # (true if message successfully sent, false if send failed.)

    if server_response[&#34;response&#34;][&#34;message&#34;] == &#34;Direct message sent&#34;:

        # saves the message that was successfully sent to the server
        msgdict = dsp.get_msg_dict(message=message, recipient=recipient)
        dm = DirectMessage(timestamp=msgdict[&#34;timestamp&#34;], message=msgdict[&#34;message&#34;], recipient=msgdict[&#34;recipient&#34;], frm=self.username)
        # dm.fill_info_sent(messagedict=messagedict, myusername=self.username)
        self.sent_messages.append(dm)

        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ds_messenger.DirectMessage" href="#ds_messenger.DirectMessage">DirectMessage</a></code></h4>
<ul class="two-column">
<li><code><a title="ds_messenger.DirectMessage.get_message" href="#ds_messenger.DirectMessage.get_message">get_message</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.get_time" href="#ds_messenger.DirectMessage.get_time">get_time</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.set_frm" href="#ds_messenger.DirectMessage.set_frm">set_frm</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.set_message" href="#ds_messenger.DirectMessage.set_message">set_message</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.set_recipient" href="#ds_messenger.DirectMessage.set_recipient">set_recipient</a></code></li>
<li><code><a title="ds_messenger.DirectMessage.set_timestamp" href="#ds_messenger.DirectMessage.set_timestamp">set_timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ds_messenger.DirectMessenger" href="#ds_messenger.DirectMessenger">DirectMessenger</a></code></h4>
<ul class="">
<li><code><a title="ds_messenger.DirectMessenger.retrieve_all" href="#ds_messenger.DirectMessenger.retrieve_all">retrieve_all</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.retrieve_new" href="#ds_messenger.DirectMessenger.retrieve_new">retrieve_new</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.send" href="#ds_messenger.DirectMessenger.send">send</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>